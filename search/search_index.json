{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Morphyn Documentation","text":""},{"location":"#morphyn-is-a-scripting-language-providing-a-clean-event-driven-syntax-to-manage-configs-and-logic-lightweight-and-opinionated-focused-entirely-on-entity-states-and-reactive-events-without-the-overhead-of-a-general-purpose-language","title":"Morphyn is a scripting language providing a clean, event-driven syntax to manage configs and logic. Lightweight and opinionated \u2014 focused entirely on entity states and reactive events, without the overhead of a general-purpose language.","text":""},{"location":"#heres-a-taste","title":"Here's a taste:","text":""},{"location":"#entity-player-has-hp-100-has-level-1-on-damageamount-hp-amount-hp-check-hp-0-emit-die-on-level_up-level-1-level-hp-20-hp","title":"<pre><code>entity Player {\n  has hp: 100\n  has level: 1\n\n  on damage(amount) {\n    hp - amount -&gt; hp\n    check hp &lt;= 0: emit die\n  }\n\n  on level_up {\n    level + 1 -&gt; level\n    hp + 20 -&gt; hp\n  }\n}\n</code></pre>","text":""},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#unity","title":"Unity","text":"<p>1. Download and import <code>Morphyn.unitypackage</code></p> <p>2. Create a <code>.morph</code> file: <pre><code>entity Enemy {\n    has hp: 100\n    has alive: true\n\n    on take_damage(amount) {\n        hp - amount -&gt; hp\n        emit log(\"Enemy hit! HP:\", hp)\n\n        check hp &lt;= 0: {\n            false -&gt; alive\n            emit log(\"Enemy defeated\")\n        }\n    }\n}\n</code></pre></p> <p>3. Use in C#: <pre><code>MorphynController.Instance.Emit(\"Enemy\", \"take_damage\", 25);\n\nbool isAlive = Convert.ToBoolean(MorphynController.Instance.GetField(\"Enemy\", \"alive\"));\n</code></pre></p> <p>4. Add <code>MorphynController</code> to your scene, drag in the <code>.morph</code> files, check Enable Hot Reload, press Play.</p> <p>Full Unity Guide \u2192</p>"},{"location":"#standalone","title":"Standalone","text":"<pre><code># Linux / macOS\n./install.sh &amp;&amp; morphyn game.morph\n\n# Windows\n.\\install.ps1; morphyn game.morph\n</code></pre> <p>Installation Guide \u2192</p>"},{"location":"#why-not-lua","title":"Why not Lua?","text":"<p>The Unity bridges are a mess. MoonSharp hasn't been updated in years. XLua is maintained but built for a different ecosystem entirely. Getting either to work with hot reload and state preservation is a project in itself.</p> <p>Morphyn exists because setting up Lua in Unity shouldn't take days. Simpler, opinionated, built specifically for game config and logic. You lose the standard library. You gain something that works on the first try.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>Entities hold state and define reactions: <pre><code>entity Shop {\n  has gold: 100\n  on buy(cost) {\n    check gold &gt;= cost: {\n      gold - cost -&gt; gold\n      emit add_item(\"sword\")\n    }\n  }\n}\n</code></pre></p> <p>Events are how entities communicate: <pre><code>emit Player.damage(25)   # Send to entity\nemit self.heal(10)       # Send to self explicitly\nemit heal(10)            # Same as above, implicit\n</code></pre></p> <p>Subscriptions let entities react to each other: <pre><code>entity Logger {\n  on init {\n    when Player.die : onPlayerDied\n  }\n  on onPlayerDied {\n    emit log(\"Player died\")\n  }\n}\n</code></pre></p> <p>Data flow with <code>-&gt;</code>: <pre><code>hp - 10 -&gt; hp       # Subtract\nmax_hp -&gt; hp        # Set\n</code></pre></p> <p>Check stop execution if condition fails(only if there is no block to execute): <pre><code>check false\n</code></pre></p>"},{"location":"#vs-code-extension","title":"VS Code Extension","text":"<p>Syntax highlighting, bracket matching, comment support for <code>.morph</code> files.</p> <p>\ud83d\udce5 Download <code>.vsix</code> from Releases \u2192 Extensions \u2192 <code>...</code> \u2192 Install from VSIX</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li>[x] Core language runtime</li> <li>[x] Unity integration</li> <li>[x] Hot reload system</li> <li>[x] VS Code extension</li> <li>[x] Event subscription system (<code>when</code> / <code>unwhen</code>)</li> <li>[x] C# listener API (<code>On</code> / <code>Off</code>)</li> <li>[ ] Async event handling</li> <li>[ ] More documentation examples</li> <li>[ ] Performance optimizations</li> <li>[ ] Self-hosted interpreter</li> </ul>"},{"location":"#learn-more","title":"Learn More","text":"<p>Getting Started: Quick Start \u00b7 Installation</p> <p>Language: Syntax Reference \u00b7 Event System \u00b7 Expression System</p> <p>Unity: Overview \u00b7 API Reference</p> <p>Learn in Y minutes: Morphyn \u00b7 Unity bridge</p>"},{"location":"#contributing","title":"Contributing","text":"<ul> <li>Report Issues</li> <li>Feature Requests (use \"enhancement\" label)</li> </ul> <p>PRs are welcome.</p>"},{"location":"#license","title":"License","text":"<p>Apache 2.0 \u2014 see LICENSE and NOTICE. Free for commercial use.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>.NET 10.0 or higher</li> </ul>"},{"location":"getting-started/installation/#standalone-runtime","title":"Standalone Runtime","text":"<p>Download from Releases: - Runtime: <code>morphyn-windows-x64.exe</code> (Windows) / <code>morphyn-linux-x64</code> (Linux/macOS) - Install script: <code>install.ps1</code> / <code>install.sh</code></p> <p>Setup: 1. Download both files for your platform 2. Run install script to add <code>morphyn</code> to PATH:    - Windows: <code>.\\install.ps1</code>    - Linux/macOS: <code>./install.sh</code></p> <p>Note</p> <p>The install script only needs to be run once.</p> <p>Usage: <pre><code># Run file\nmorphyn main.morph\n</code></pre></p>"},{"location":"getting-started/installation/#build-from-source","title":"Build from Source","text":"<p>Clone the repository: <pre><code>git clone https://github.com/jvnkoo/morphyn.git\ncd morphyn\n</code></pre></p> <p>Build the project: <pre><code>dotnet build --framework net10.0 \n</code></pre></p> <p>The compiled binary will be in <code>bin/Debug/net10.0/</code> or <code>bin/Release/net10.0/</code>.</p>"},{"location":"getting-started/installation/#file-extensions","title":"File Extensions","text":"<p>Morphyn recognizes the following file extensions: - <code>.morphyn</code>  - <code>.morph</code> (recommended) - <code>.mrph</code></p>"},{"location":"getting-started/installation/#development-branches","title":"Development Branches","text":"<p>Note</p> <p>Development of ecosystem components is organized into branches:</p> <ul> <li>Unity Package: Switch to the <code>unity-bridge</code> branch</li> <li>VS Code Extension: Switch to the <code>vscode-extension</code> branch</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":""},{"location":"getting-started/quick-start/#your-first-program","title":"Your First Program","text":"<p>Create a file called <code>player.morph</code>: <pre><code>entity Player {\n  has hp: 100\n  has name: \"Hero\"\n\n  on init {\n    emit log(\"Player created!\")\n    emit damage(25)  # Trigger damage event from init\n  }\n\n  on damage(amount) {\n    hp - amount -&gt; hp\n    emit log(\"HP remaining:\", hp)\n    check hp &lt;= 0: emit die\n  }\n\n  on die {\n    emit log(\"Game Over\")\n  }\n}\n</code></pre></p>"},{"location":"getting-started/quick-start/#running-morphyn-programs","title":"Running Morphyn Programs","text":"<p>Run your program: <pre><code>morphyn player.morph\n</code></pre></p> <p>Output: <pre><code>Player created!\nHP remaining: 75\n</code></pre></p>"},{"location":"getting-started/quick-start/#how-events-work","title":"How Events Work","text":"<p>Events in Morphyn are reactive, not automatic. They only run when:</p> <ol> <li> <p>Triggered from <code>init</code> or <code>tick</code>: <pre><code>entity Game {\n  on init {\n    emit player.damage(50)  # Triggers player's damage event\n  }\n\n  on tick(dt) {\n    emit enemy.update(dt)   # Triggers enemy's update event\n  }\n}\n</code></pre></p> </li> <li> <p>Triggered externally (from C# in Unity): <pre><code>MorphynController.Instance.Emit(\"Player\", \"damage\", 50);\n</code></pre></p> </li> <li> <p>Chained from other events: <pre><code>on damage(amount) {\n  hp - amount -&gt; hp\n  check hp &lt;= 0: emit die  # damage triggers die\n}\n</code></pre></p> </li> </ol> <p>Important</p> <p>Custom events like <code>damage</code>, <code>heal</code>, <code>attack</code> will not run unless explicitly triggered. Only <code>init</code> and <code>tick</code> run automatically.</p>"},{"location":"getting-started/quick-start/#runtime-features","title":"Runtime Features","text":""},{"location":"getting-started/quick-start/#hot-reload","title":"Hot Reload","text":"<p>The runtime automatically watches for file changes and reloads entity logic without restarting.</p> <p>Example: 1. Run <code>morphyn player.morph</code> 2. Edit the file: change <code>emit damage(25)</code> to <code>emit damage(75)</code> 3. Save 4. Logic updates instantly without restarting</p>"},{"location":"getting-started/quick-start/#tick-system","title":"Tick System","text":"<p>Entities with a <code>tick</code> event receive frame updates: <pre><code>entity Timer {\n  has elapsed: 0\n\n  on tick(dt) {\n    # dt = milliseconds since last frame\n    elapsed + dt -&gt; elapsed\n    emit log(\"Time:\", elapsed)\n  }\n}\n</code></pre></p>"},{"location":"getting-started/quick-start/#init-event","title":"Init Event","text":"<p>Runs once when entity is created: <pre><code>entity Player {\n  has hp: 100\n\n  on init {\n    emit log(\"Player spawned with\", hp, \"HP\")\n  }\n}\n</code></pre></p>"},{"location":"language/events/","title":"Event System","text":""},{"location":"language/events/#overview","title":"Overview","text":"<p>Morphyn uses an event queue to process entity reactions. Events are processed in order, and each event can trigger additional events.</p>"},{"location":"language/events/#built-in-events","title":"Built-in Events","text":""},{"location":"language/events/#init","title":"init","text":"<p>Called when an entity is first created or spawned: <pre><code>entity Enemy {\n  has hp: 50\n  on init {\n    emit log(\"Enemy spawned\")\n  }\n}\n</code></pre></p>"},{"location":"language/events/#tickdt","title":"tick(dt)","text":"<p>Called every frame with delta time in milliseconds: <pre><code>entity Timer {\n  has time: 0\n  on tick(dt) {\n    time + dt -&gt; time\n  }\n}\n</code></pre></p>"},{"location":"language/events/#destroy","title":"destroy","text":"<p>Marks entity for garbage collection: <pre><code>entity Enemy {\n  has hp: 50\n  on damage(v) {\n    hp - v -&gt; hp\n    check hp &lt;= 0: emit self.destroy\n  }\n}\n</code></pre></p>"},{"location":"language/events/#custom-events","title":"Custom Events","text":"<p>Define your own events: <pre><code>entity Player {\n  on jump {\n    emit log(\"Player jumped!\")\n  }\n  on heal(amount) {\n    hp + amount -&gt; hp\n  }\n}\n</code></pre></p>"},{"location":"language/events/#sending-events","title":"Sending Events","text":""},{"location":"language/events/#send-to-self","title":"Send to Self","text":"<pre><code>emit event_name \n\n# or\n\nemit self.event_name\n\nemit heal(10)\n</code></pre>"},{"location":"language/events/#send-to-target","title":"Send to Target","text":"<pre><code>emit target.event_name\nemit player.damage(5)\n</code></pre>"},{"location":"language/events/#send-to-self-with-destroy","title":"Send to Self with destroy","text":"<pre><code>emit self.destroy\n</code></pre>"},{"location":"language/events/#event-subscriptions","title":"Event Subscriptions","text":"<p>Entities can subscribe to events of other entities using <code>when</code> and unsubscribe using <code>unwhen</code>.</p>"},{"location":"language/events/#syntax","title":"Syntax","text":"<pre><code>when TargetEntity.eventName : handlerEvent\nunwhen TargetEntity.eventName : handlerEvent\n</code></pre> <p>When <code>TargetEntity.eventName</code> fires, the runtime automatically sends <code>handlerEvent</code> to the subscribing entity, passing the same arguments.</p>"},{"location":"language/events/#basic-example","title":"Basic Example","text":"<pre><code>entity Logger {\n  on init {\n    when Player.death : onPlayerDeath\n    when Player.levelUp : onPlayerLevelUp\n  }\n\n  on onPlayerDeath {\n    emit log(\"Player has died!\")\n  }\n\n  on onPlayerLevelUp(level) {\n    emit log(\"Player reached level:\", level)\n  }\n}\n\nentity Player {\n  has hp: 100\n  has level: 1\n\n  on death {\n    emit log(\"Player died!\")\n  }\n\n  on levelUp(level) {\n    emit log(\"Level up:\", level)\n  }\n}\n</code></pre>"},{"location":"language/events/#unsubscribing","title":"Unsubscribing","text":"<p>Use <code>unwhen</code> to stop receiving events: <pre><code>entity Logger {\n  on init {\n    when Player.death : onPlayerDeath\n  }\n\n  on onPlayerDeath {\n    emit log(\"Player died \u2014 unsubscribing now\")\n    unwhen Player.death : onPlayerDeath\n  }\n}\n</code></pre></p>"},{"location":"language/events/#arguments","title":"Arguments","text":"<p>The subscriber's handler receives the same arguments as the original event: <pre><code>entity UI {\n  on init {\n    when Player.takeDamage : onDamage\n  }\n\n  on onDamage(amount) {\n    emit log(\"UI: player took\", amount, \"damage\")\n  }\n}\n\nentity Player {\n  on takeDamage(amount) {\n    hp - amount -&gt; hp\n  }\n}\n</code></pre></p> <p>If the handler declares no parameters, it simply ignores the arguments \u2014 no error: <pre><code>on onDamage {\n  emit log(\"Player was hit\")\n}\n</code></pre></p>"},{"location":"language/events/#rules","title":"Rules","text":"<ul> <li>An entity cannot subscribe to its own instance's events. A specific entity instance cannot listen to events it fires itself \u2014 the subscriber and the target must be different instances: <pre><code>entity Logger {\n  on init {\n    when Logger.something : onSomething  # runtime error \u2014 same instance subscribing to itself\n    when Player.death : onPlayerDeath    # ok \u2014 different entity\n  }\n}\n</code></pre> Two different clones of the same entity type (e.g. spawned via <code>pool.add</code>) are separate instances and can subscribe to each other normally.</li> <li>Duplicate subscriptions are ignored. Subscribing the same handler to the same event twice has no effect.</li> <li>Dead entities are cleaned up automatically. If a subscriber is destroyed, its subscriptions are removed during garbage collection.</li> <li><code>when</code> and <code>unwhen</code> can be used anywhere \u2014 inside <code>on init</code>, <code>on tick</code>, or any other event handler.</li> </ul>"},{"location":"language/events/#multiple-subscribers","title":"Multiple Subscribers","text":"<p>Multiple entities can subscribe to the same event independently: <pre><code>entity Logger {\n  on init {\n    when Player.death : onPlayerDeath\n  }\n  on onPlayerDeath {\n    emit log(\"Logger: player died\")\n  }\n}\n\nentity UI {\n  on init {\n    when Player.death : onPlayerDeath\n  }\n  on onPlayerDeath {\n    emit log(\"UI: showing death screen\")\n  }\n}\n\nentity Stats {\n  on init {\n    when Player.death : recordDeath\n  }\n  on recordDeath {\n    deaths + 1 -&gt; deaths\n  }\n}\n</code></pre></p> <p>All three will react when <code>Player.death</code> fires.</p>"},{"location":"language/events/#built-in-functions","title":"Built-in Functions","text":"<p>Built-in functions are called via <code>emit</code> but handled directly by the runtime.</p>"},{"location":"language/events/#log","title":"log","text":"<p>Prints values to console: <pre><code>emit log(\"HP:\", hp)\nemit log(\"Position:\", x, y)\nemit log(\"Pool:\", items)\n</code></pre></p>"},{"location":"language/events/#input","title":"input","text":"<p>Reads a line from console and writes the value to a field: <pre><code>emit input(\"Enter your name: \", \"name\")\nemit input(\"Enter amount: \", \"amount\")\n</code></pre> - First argument: prompt string shown to user - Second argument: field name as a string literal (in quotes) - If the input can be parsed as a number, it is stored as a number - Otherwise stored as a string</p> <p>Note</p> <p>The field name must be passed as a string literal in quotes: <code>\"fieldName\"</code>. Writing <code>emit input(\"prompt\", fieldName)</code> will not work \u2014 <code>fieldName</code> would be evaluated as a variable, not as a field name.</p> <p>Example \u2014 interactive calculator: <pre><code>entity Calc {\n  has a: 0\n  has b: 0\n  has op: \"\"\n  on init {\n    emit input(\"First number: \", \"a\")\n    emit input(\"Operator (+,-,*,/): \", \"op\")\n    emit input(\"Second number: \", \"b\")\n    emit calculate\n  }\n  on calculate {\n    check op == \"+\": emit log(a, \"+\", b, \"=\", a + b)\n    check op == \"-\": emit log(a, \"-\", b, \"=\", a - b)\n    check op == \"*\": emit log(a, \"*\", b, \"=\", a * b)\n    check op == \"/\": {\n      check b == 0: emit log(\"error: division by zero\")\n      check b != 0: emit log(a, \"/\", b, \"=\", a / b)\n    }\n  }\n}\n</code></pre></p>"},{"location":"language/events/#unity","title":"unity","text":"<p>Calls a registered Unity callback: <pre><code>emit unity(\"PlaySound\", \"explosion\")\nemit unity(\"SpawnEnemy\", x, y)\n</code></pre></p>"},{"location":"language/expressions/","title":"Expression System","text":""},{"location":"language/expressions/#expression-types","title":"Expression Types","text":""},{"location":"language/expressions/#literals","title":"Literals","text":""},{"location":"language/expressions/#numbers","title":"Numbers","text":"<pre><code>100           # Integer\n3.14          # Floating point\n-42           # Negative\n</code></pre>"},{"location":"language/expressions/#strings","title":"Strings","text":"<pre><code>\"Hello\"\n\"Player Name\"\n</code></pre>"},{"location":"language/expressions/#booleans","title":"Booleans","text":"<pre><code>true\nfalse\n</code></pre>"},{"location":"language/expressions/#null","title":"Null","text":"<pre><code>null\n</code></pre>"},{"location":"language/expressions/#variables","title":"Variables","text":""},{"location":"language/expressions/#entity-fields","title":"Entity Fields","text":"<pre><code>has hp: 50\nhas name: noname\nhas alive: true\n</code></pre>"},{"location":"language/expressions/#event-parameters","title":"Event Parameters","text":"<pre><code>on damage(amount) {\n  hp - amount -&gt; hp  # 'amount' is a parameter\n}\n</code></pre>"},{"location":"language/expressions/#arithmetic-operators","title":"Arithmetic Operators","text":""},{"location":"language/expressions/#basic-math","title":"Basic Math","text":"<pre><code>hp + 10       # Addition\nhp - 5        # Subtraction\ndamage * 2    # Multiplication\narmor / 3     # Division\nlevel % 5     # Modulo\n</code></pre>"},{"location":"language/expressions/#complex-expressions","title":"Complex Expressions","text":"<pre><code>(hp + shield) * 0.5 -&gt; total_defense\ndamage * (1 - armor / 100) -&gt; final_damage\n</code></pre>"},{"location":"language/expressions/#comparison-operators","title":"Comparison Operators","text":"<pre><code>hp &gt; 0           # Greater than\nlevel &gt;= 10      # Greater or equal\nhp &lt; max_hp      # Less than\nmana &lt;= 0        # Less or equal\nstate == \"idle\"  # Equal\nhp != 0          # Not equal\n</code></pre>"},{"location":"language/expressions/#logic-operators","title":"Logic Operators","text":""},{"location":"language/expressions/#and","title":"AND","text":"<pre><code>check hp &gt; 0 and mana &gt; 10: emit cast_spell\n</code></pre>"},{"location":"language/expressions/#or","title":"OR","text":"<pre><code>check state == \"idle\" or state == \"walk\": emit can_interact\n</code></pre>"},{"location":"language/expressions/#not","title":"NOT","text":"<pre><code>check not dead: emit move\ncheck not (hp &lt; 10 and mana &lt; 5): emit safe_to_fight\n</code></pre>"},{"location":"language/expressions/#pool-access","title":"Pool Access","text":""},{"location":"language/expressions/#get-pool-size","title":"Get Pool Size","text":"<pre><code>enemies.count -&gt; num_enemies\n</code></pre>"},{"location":"language/expressions/#access-by-index-1-based","title":"Access by Index (1-based)","text":"<pre><code>enemies.at[1] -&gt; first_enemy\nitems.at[i] -&gt; current_item\n</code></pre>"},{"location":"language/expressions/#access-entity-fields","title":"Access Entity Fields","text":"<pre><code>player.hp -&gt; player_health\nenemy.damage -&gt; incoming_damage\n</code></pre>"},{"location":"language/imports/","title":"Import System","text":""},{"location":"language/imports/#import-syntax","title":"Import Syntax","text":"<p>Import other Morphyn files: <pre><code>import \"enemies.morph\"\nimport \"core/weapons.morph\"\nimport \"../shared/items.morph\"\n\nentity Player {\n  # Can use entities from imported files\n}\n</code></pre></p>"},{"location":"language/imports/#import-rules","title":"Import Rules","text":"<ul> <li>Imports are resolved relative to the importing file</li> <li>Circular imports are automatically prevented</li> <li>Import statements must end with semicolon</li> <li>Missing import files generate warnings but don't stop execution</li> </ul>"},{"location":"language/imports/#examples","title":"Examples","text":""},{"location":"language/imports/#basic-import","title":"Basic Import","text":"<p>main.morph: <pre><code>import \"player.morph\"\nimport \"enemy.morph\"\n\nentity Game {\n  on init {\n    emit log(\"Game started\")\n  }\n}\n</code></pre></p>"},{"location":"language/imports/#subdirectory-imports","title":"Subdirectory Imports","text":"<pre><code>import \"entities/player.morph\"\nimport \"entities/enemy.morph\"\nimport \"systems/combat.morph\"\n</code></pre>"},{"location":"language/imports/#relative-imports","title":"Relative Imports","text":"<pre><code>import \"../shared/utils.morph\"\nimport \"../../core/base.morph\"\n</code></pre>"},{"location":"language/pools/","title":"Pool System","text":""},{"location":"language/pools/#overview","title":"Overview","text":"<p>Pools are collections of entities or values in Morphyn. They provide high-performance storage for game objects.</p>"},{"location":"language/pools/#declaration","title":"Declaration","text":"<pre><code>entity World {\n  has enemies: pool[1, 2, 3]\n  has items: pool[\"sword\", \"shield\"]\n  has positions: pool[0.0, 10.5, 20.3]\n}\n</code></pre>"},{"location":"language/pools/#pool-commands","title":"Pool Commands","text":""},{"location":"language/pools/#adding-elements","title":"Adding Elements","text":""},{"location":"language/pools/#add-add-entity-instance","title":"add - Add entity instance","text":"<pre><code>emit enemies.add(Enemy)  # Creates new Enemy and adds to pool\n</code></pre>"},{"location":"language/pools/#push-add-to-front","title":"push - Add to front","text":"<pre><code>emit items.push(\"new_item\")\n</code></pre>"},{"location":"language/pools/#insert-insert-at-position-1-based-index","title":"insert - Insert at position (1-based index)","text":"<pre><code>emit items.insert(2, \"middle_item\")\n</code></pre>"},{"location":"language/pools/#removing-elements","title":"Removing Elements","text":""},{"location":"language/pools/#remove-remove-specific-value","title":"remove - Remove specific value","text":"<pre><code>emit enemies.remove(target)\n</code></pre>"},{"location":"language/pools/#remove_at-remove-at-index-1-based","title":"remove_at - Remove at index (1-based)","text":"<pre><code>emit enemies.remove_at(3)\n</code></pre>"},{"location":"language/pools/#pop-remove-last-element","title":"pop - Remove last element","text":"<pre><code>emit items.pop\n</code></pre>"},{"location":"language/pools/#shift-remove-first-element","title":"shift - Remove first element","text":"<pre><code>emit items.shift\n</code></pre>"},{"location":"language/pools/#clear-remove-all-elements","title":"clear - Remove all elements","text":"<pre><code>emit enemies.clear\n</code></pre>"},{"location":"language/pools/#other-operations","title":"Other Operations","text":""},{"location":"language/pools/#swap-swap-two-elements-1-based-indices","title":"swap - Swap two elements (1-based indices)","text":"<pre><code>emit items.swap(1, 3)\n</code></pre>"},{"location":"language/pools/#each-call-event-on-each-element","title":"each - Call event on each element","text":"<pre><code>emit enemies.each(update, dt)\nemit items.each(collect, player)\n</code></pre>"},{"location":"language/pools/#accessing-pools","title":"Accessing Pools","text":""},{"location":"language/pools/#get-pool-size","title":"Get pool size","text":"<pre><code>enemies.count -&gt; num_enemies\n</code></pre>"},{"location":"language/pools/#access-by-index-1-based","title":"Access by index (1-based)","text":"<pre><code>enemies.at[1] -&gt; first_enemy\nenemies.at[i] -&gt; current_enemy\n</code></pre>"},{"location":"language/pools/#set-by-index","title":"Set by index","text":"<pre><code>new_value -&gt; pool.at[index]\n</code></pre>"},{"location":"language/sync-emit/","title":"Sync Emit","text":""},{"location":"language/sync-emit/#overview","title":"Overview","text":"<p>Sync emit is a special form of <code>emit</code> that executes an event immediately and synchronously, bypassing the event queue, and assigns the result to a field. <pre><code>emit Entity.event(args) -&gt; field\n</code></pre> This enables user-defined pure functions \u2014 events that compute and return a value.</p>"},{"location":"language/sync-emit/#syntax","title":"Syntax","text":"<p><pre><code>emit EventName(args) -&gt; field\nemit Entity.event(args) -&gt; field\n</code></pre> The result written to <code>field</code> is the last assigned value inside the called event.</p>"},{"location":"language/sync-emit/#example","title":"Example","text":"<pre><code>entity MathLib {\n  on clamp(value, min, max) {\n    check value &lt; min: min -&gt; value\n    check value &gt; max: max -&gt; value\n    value -&gt; result\n  }\n  on abs(value) {\n    check value &lt; 0: value * -1 -&gt; value\n    value -&gt; result\n  }\n  on lerp(a, b, t) {\n    a + (b - a) * t -&gt; result\n  }\n}\nentity Player {\n  has hp: 150\n  has max_hp: 100\n  has x: 0.0\n  on heal(amount) {\n    emit MathLib.clamp(hp + amount, 0, max_hp) -&gt; hp\n  }\n  on tick(dt) {\n    emit MathLib.lerp(x, 10, 0.1) -&gt; x\n  }\n}\n</code></pre>"},{"location":"language/sync-emit/#rules","title":"Rules","text":""},{"location":"language/sync-emit/#sync-calls-can-be-chained","title":"Sync calls can be chained","text":"<p><code>emit X() -&gt; field</code> can be used inside another sync event, as long as the target is a different event. Chains like <code>A -&gt; B -&gt; C</code> are fully supported:</p> <pre><code>entity Pipeline {\n  on process(value) {\n    emit MathLib.abs(value) -&gt; value            # ok \u2014 calls MathLib.abs\n    emit MathLib.clamp(value, 0, 100) -&gt; value  # ok \u2014 calls MathLib.clamp\n    value -&gt; result\n  }\n}\n\nentity MathLib {\n  on abs(value) {\n    check value &lt; 0: value * -1 -&gt; value\n    value -&gt; result\n  }\n  on clamp(value, min, max) {\n    check value &lt; min: min -&gt; value\n    check value &gt; max: max -&gt; value\n    value -&gt; result\n  }\n}\n</code></pre>"},{"location":"language/sync-emit/#direct-recursion-is-forbidden","title":"Direct recursion is forbidden","text":"<p>An event cannot call itself synchronously. This prevents infinite loops:</p> <pre><code>entity Bad {\n  on recurse(value) {\n    emit Bad.recurse(value) -&gt; value  # runtime error \u2014 recursive sync call\n  }\n}\n</code></pre> <p>The check is per <code>(entity, event)</code> pair \u2014 <code>A.foo</code> calling <code>A.foo</code> is forbidden, but <code>A.foo</code> calling <code>A.bar</code> or <code>B.foo</code> is fine.</p>"},{"location":"language/sync-emit/#regular-emit-inside-sync-events","title":"Regular emit inside sync events","text":"<p>Regular <code>emit</code> is allowed inside sync events. The events are held in a separate side-effect queue and flushed to the main queue after the outermost sync call completes. This means side effects happen after the result is returned, not during.</p> <pre><code>entity MathLib {\n  on clamp(value, min, max) {\n    check value &lt; min: min -&gt; value\n    check value &gt; max: max -&gt; value\n    value -&gt; result\n    emit log(\"clamped:\", result)  # queued, fires after sync call returns\n  }\n}\n</code></pre>"},{"location":"language/sync-emit/#return-value","title":"Return value","text":"<p>The return value is the last value assigned inside the event body, regardless of which branch executed. <pre><code>on clamp(value, min, max) {\n  check value &lt; min: min -&gt; value\n  check value &gt; max: max -&gt; value\n  value -&gt; result             # this is the return value\n}\n</code></pre></p>"},{"location":"language/sync-emit/#comparison-with-regular-emit","title":"Comparison with regular emit","text":"<code>emit X()</code> <code>emit X() -&gt; field</code> Execution Queued, deferred Immediate, synchronous Return value None Last assigned value <code>emit X() -&gt; field</code> allowed inside Yes Yes, unless recursive Regular <code>emit</code> allowed inside Yes Yes (deferred to after sync) Recursion Yes (indirect) No (runtime error) Chaining to other events \u2014 Yes Use case Events, side effects Pure computation, pipelines"},{"location":"language/sync-emit/#use-cases","title":"Use Cases","text":""},{"location":"language/sync-emit/#math-utilities","title":"Math utilities","text":"<pre><code>entity MathLib {\n  on clamp(value, min, max) {\n    check value &lt; min: min -&gt; value\n    check value &gt; max: max -&gt; value\n    value -&gt; result\n  }\n  on abs(value) {\n    check value &lt; 0: value * -1 -&gt; value\n    value -&gt; result\n  }\n  on lerp(a, b, t) {\n    a + (b - a) * t -&gt; result\n  }\n  on normalize(value, min, max) {\n    (value - min) / (max - min) -&gt; result\n  }\n}\n</code></pre>"},{"location":"language/sync-emit/#chained-computation","title":"Chained computation","text":"<pre><code>entity StatLib {\n  on raw_to_final(damage, armor, crit) {\n    emit StatLib.apply_armor(damage, armor) -&gt; damage\n    emit StatLib.apply_crit(damage, crit) -&gt; damage\n    damage -&gt; result\n  }\n  on apply_armor(damage, armor) {\n    damage * (1 - armor / 100) -&gt; result\n  }\n  on apply_crit(damage, crit) {\n    check crit: damage * 2 -&gt; damage\n    damage -&gt; result\n  }\n}\nentity Player {\n  has hp: 100\n  has armor: 30\n  on take_damage(raw, crit) {\n    emit StatLib.raw_to_final(raw, armor, crit) -&gt; final\n    hp - final -&gt; hp\n    check hp &lt;= 0: emit die\n  }\n}\n</code></pre>"},{"location":"language/sync-emit/#stat-computation","title":"Stat computation","text":"<pre><code>entity StatLib {\n  on apply_armor(damage, armor) {\n    damage * (1 - armor / 100) -&gt; result\n  }\n  on exp_to_next(level) {\n    level * level * 50 -&gt; result\n  }\n}\nentity Player {\n  has hp: 100\n  has armor: 30\n  has level: 5\n  has exp: 0\n  on take_damage(amount) {\n    emit StatLib.apply_armor(amount, armor) -&gt; amount\n    hp - amount -&gt; hp\n    check hp &lt;= 0: emit die\n  }\n  on add_exp(amount) {\n    exp + amount -&gt; exp\n    emit StatLib.exp_to_next(level) -&gt; needed\n    check exp &gt;= needed: emit level_up\n  }\n}\n</code></pre>"},{"location":"language/sync-emit/#shared-library-via-import","title":"Shared library via import","text":"<p>mathlib.morph: <pre><code>entity MathLib {\n  on clamp(value, min, max) {\n    check value &lt; min: min -&gt; value\n    check value &gt; max: max -&gt; value\n    value -&gt; result\n  }\n}\n</code></pre> game.morph: <pre><code>import \"mathlib.morph\"\nentity Player {\n  has hp: 100\n  has max_hp: 100\n  on heal(amount) {\n    emit MathLib.clamp(hp + amount, 0, max_hp) -&gt; hp\n  }\n}\n</code></pre></p>"},{"location":"language/syntax/","title":"Language Syntax Reference","text":""},{"location":"language/syntax/#overview","title":"Overview","text":"<p>Morphyn is a declarative language with minimal syntax. Programs consist of entity declarations with fields and event handlers.</p>"},{"location":"language/syntax/#comments","title":"Comments","text":"<p>Three comment styles are supported: <pre><code># Single-line comment (shell style)\n// Single-line comment (C++ style)\n/* Multi-line comment */\n</code></pre></p>"},{"location":"language/syntax/#entity-declaration","title":"Entity Declaration","text":"<pre><code>entity EntityName {\n  # Fields and events\n}\n</code></pre>"},{"location":"language/syntax/#field-declaration","title":"Field Declaration","text":""},{"location":"language/syntax/#basic-fields","title":"Basic Fields","text":"<pre><code>has field_name: value\nhas hp: 100\nhas name: \"Player\"\nhas alive: true\nhas exist: null\n</code></pre>"},{"location":"language/syntax/#pool-fields","title":"Pool Fields","text":"<pre><code>has items: pool[1, 2, 3]\nhas names: pool[\"Alice\", \"Bob\"]\nhas flags: pool[true, false, true]\n</code></pre>"},{"location":"language/syntax/#event-handlers","title":"Event Handlers","text":""},{"location":"language/syntax/#without-parameters","title":"Without Parameters","text":"<pre><code>on event_name {\n  # actions\n}\n</code></pre>"},{"location":"language/syntax/#with-parameters","title":"With Parameters","text":"<pre><code>on event_name(param1, param2) {\n  # actions\n}\n</code></pre>"},{"location":"language/syntax/#actions","title":"Actions","text":""},{"location":"language/syntax/#data-flow-arrow","title":"Data Flow (Arrow)","text":"<pre><code>expression -&gt; target\nhp - 10 -&gt; hp\ndamage * 2 -&gt; result\n0 -&gt; counter\n</code></pre>"},{"location":"language/syntax/#check-guard","title":"Check (Guard)","text":"<pre><code># Check with an inline action\ncheck condition: action\ncheck hp &gt; 0: emit alive\ncheck state == \"idle\": emit can_move\n# Check without an inline action (guard)\n# If false, the event execution is stopped\ncheck i &lt; 0\n</code></pre>"},{"location":"language/syntax/#emit-event-dispatch","title":"Emit (Event Dispatch)","text":"<pre><code>emit event_name\nemit event_name(arg1, arg2)\nemit target.event_name\nemit self.destroy\nemit log(\"message\", value)\nemit input(\"prompt: \", \"fieldName\")\n</code></pre>"},{"location":"language/syntax/#sync-emit-immediate-call-with-return-value","title":"Sync Emit (Immediate Call with Return Value)","text":"<p>Executes an event synchronously and assigns the result to a field. The result is the last value assigned inside the called event. <pre><code>emit event_name(args) -&gt; field\nemit Entity.event_name(args) -&gt; field\nemit Entity.event_name(args) -&gt; pool.at[idx]\n</code></pre> Sync calls can be chained \u2014 direct recursion (an event calling itself) is forbidden. <pre><code>entity MathLib {\n  on clamp(value, min, max) {\n    check value &lt; min: min -&gt; value\n    check value &gt; max: max -&gt; value\n    value -&gt; result\n  }\n}\nentity Player {\n  has hp: 150\n  has max_hp: 100\n  on heal(amount) {\n    emit MathLib.clamp(hp + amount, 0, max_hp) -&gt; hp\n  }\n}\n</code></pre></p>"},{"location":"language/syntax/#subscriptions","title":"Subscriptions","text":"<p>Subscribe to events of another entity: <pre><code>when TargetEntity.eventName : handlerEvent\nunwhen TargetEntity.eventName : handlerEvent\n</code></pre> <pre><code>entity Logger {\n  on init {\n    when Player.death : onPlayerDeath\n  }\n  on onPlayerDeath {\n    emit log(\"Player died!\")\n  }\n}\n</code></pre></p>"},{"location":"language/syntax/#block-actions","title":"Block Actions","text":"<pre><code>{\n  action1\n  action2\n  action3\n}\n</code></pre>"},{"location":"language/syntax/#built-in-functions","title":"Built-in Functions","text":"Function Description Example <code>log</code> Print to console <code>emit log(\"HP:\", hp)</code> <code>input</code> Read line from console into field <code>emit input(\"Name: \", \"name\")</code> <code>unity</code> Call Unity callback <code>emit unity(\"PlaySound\", \"hit\")</code> ### input Reads a line from console and writes the result into a field. The field name must be passed as a string literal in quotes. <pre><code>emit input(\"Enter your name: \", \"name\")\nemit input(\"Enter amount: \", \"amount\")\n</code></pre> If the input can be parsed as a number it is stored as a number, otherwise as a string. ## Operators ### Arithmetic Operator Description Example ---------- ------------- --------- <code>+</code> Addition <code>hp + 10</code> <code>-</code> Subtraction <code>hp - 5</code> <code>*</code> Multiplication <code>damage * 2</code> <code>/</code> Division <code>armor / 3</code> <code>%</code> Modulo <code>level % 5</code> ### Comparison Operator Description Example ---------- ------------- --------- <code>==</code> Equal <code>hp == 100</code> <code>!=</code> Not equal <code>state != \"dead\"</code> <code>&gt;</code> Greater than <code>hp &gt; 0</code> <code>&lt;</code> Less than <code>hp &lt; max</code> <code>&gt;=</code> Greater or equal <code>level &gt;= 10</code> <code>&lt;=</code> Less or equal <code>mana &lt;= 0</code> ### Logic Operator Description Example ---------- ------------- --------- <code>and</code> Logical AND <code>hp &gt; 0 and alive</code> <code>or</code> Logical OR <code>idle or walk</code> <code>not</code> Logical NOT <code>not dead</code> ### Flow Operator Description Example ---------- ------------- --------- <code>-&gt;</code> Data flow <code>value -&gt; field</code> ## Keywords Keyword Purpose --------- --------- <code>entity</code> Declare entity <code>has</code> Declare field <code>on</code> Declare event handler <code>emit</code> Send event, call sync event, or call built-in function <code>check</code> Conditional guard <code>pool</code> Collection type <code>when</code> Subscribe to another entity's event <code>unwhen</code> Unsubscribe from another entity's event <code>true</code> Boolean true <code>false</code> Boolean false <code>null</code> Null value"},{"location":"learn/learn-unity/","title":"Learn Morphyn Unity Bridge in Y Minutes","text":"<pre><code>using UnityEngine;\nusing Morphyn.Unity;\n\n// \u2500\u2500 SETUP \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// 1. Add MorphynController component to a GameObject in your scene\n// 2. Drag .morph files into the Morphyn Scripts array\n// 3. Press Play\n\n// MorphynController is a singleton\nMorphynController morphyn = MorphynController.Instance;\n\n\n// \u2500\u2500 READ / WRITE FIELDS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nobject raw = morphyn.GetField(\"Player\", \"hp\");\ndouble hp  = System.Convert.ToDouble(raw);\nstring name = raw?.ToString() ?? \"\";\n\nmorphyn.SetField(\"Player\", \"hp\", 50.0);\nmorphyn.SetField(\"Player\", \"alive\", false);\nmorphyn.SetField(\"Player\", \"name\", \"Hero\");\n\n// Get all fields at once\nDictionary&lt;string, object?&gt; fields = morphyn.GetAllFields(\"Player\");\n\n\n// \u2500\u2500 TRIGGER EVENTS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nmorphyn.Emit(\"Player\", \"damage\", 25);           // fire and forget\nmorphyn.Emit(\"Player\", \"heal\", 20);\nmorphyn.Emit(\"Enemy\", \"take_damage\", 10, true); // multiple args\n\n\n// \u2500\u2500 SYNC EMIT (returns a value) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// Executes immediately, returns last assigned value inside the event\nobject? result = morphyn.EmitSync(\"MathLib\", \"clamp\", 150.0, 0.0, 100.0);\ndouble clamped = System.Convert.ToDouble(result); // 100\n\n\n// \u2500\u2500 C# LISTENERS: subscribe a C# method to a Morphyn event \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// handler receives original event args as object?[]\n\nAction&lt;object?[]&gt; onDeath = args =&gt; {\n    Debug.Log(\"Player died\");\n    deathScreen.SetActive(true);\n};\n\nmorphyn.On(\"Player\", \"death\", onDeath);\n// or inline:\nmorphyn.On(\"Player\", \"levelUp\", args =&gt; {\n    int level = System.Convert.ToInt32(args[0]);\n    levelUpUI.Show(level);\n});\n\n// unsubscribe \u2014 always call in OnDestroy to avoid memory leaks\nmorphyn.Off(\"Player\", \"death\", onDeath);\n\npublic class MyComponent : MonoBehaviour\n{\n    void Start()\n    {\n        MorphynController.Instance.On(\"Player\", \"death\", OnPlayerDeath);\n    }\n\n    void OnPlayerDeath(object?[] args) { /* ... */ }\n\n    void OnDestroy()\n    {\n        // important: prevents calls on destroyed objects\n        MorphynController.Instance.Off(\"Player\", \"death\", OnPlayerDeath);\n    }\n}\n\n\n// \u2500\u2500 MORPHYN-TO-MORPHYN SUBSCRIPTIONS FROM C# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// equivalent to writing `when Player.death : onPlayerDeath` in .morph\n\nmorphyn.Subscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n// subscriberEntity, targetEntity, targetEvent, handlerEvent\n\nmorphyn.Unsubscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n\n// On vs Subscribe:\n// On / Off      \u2014 C# method reacts to Morphyn event\n// Subscribe     \u2014 Morphyn entity reacts to another Morphyn entity's event\n\n\n// \u2500\u2500 UNITY BRIDGE: call Unity from .morph \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// In .morph:\n//   emit unity(\"PlaySound\", \"explosion\")\n//   emit unity(\"SpawnVFX\", x, y, z)\n\n// Register callbacks BEFORE MorphynController loads (use Awake, not Start)\n[DefaultExecutionOrder(-100)]\npublic class Setup : MonoBehaviour\n{\n    void Awake()\n    {\n        UnityBridge.Instance.RegisterCallback(\"PlaySound\", args =&gt; {\n            string clip = args[0]?.ToString() ?? \"\";\n            AudioSource.PlayClipAtPoint(Resources.Load&lt;AudioClip&gt;(clip), Vector3.zero);\n        });\n\n        UnityBridge.Instance.RegisterCallback(\"SpawnVFX\", args =&gt; {\n            float x = System.Convert.ToSingle(args[0]);\n            float y = System.Convert.ToSingle(args[1]);\n            float z = System.Convert.ToSingle(args[2]);\n            Instantiate(vfxPrefab, new Vector3(x, y, z), Quaternion.identity);\n        });\n    }\n}\n\n// Built-in callbacks registered by MorphynController automatically:\n//   emit unity(\"Log\", \"msg\")        \u2192 Debug.Log\n//   emit unity(\"Move\", x, y, z)     \u2192 moves MorphynController's transform\n//   emit unity(\"Rotate\", angle)     \u2192 rotates MorphynController's transform\n\n\n// \u2500\u2500 SAVE / LOAD \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nmorphyn.SaveState();                // saves all entities to persistentDataPath/MorphynData/\nmorphyn.LoadState(\"Player\");        // loads fields for one entity\nmorphyn.LoadAllStates();            // loads all\n\n// Per-file save policy \u2014 set in Inspector on each MorphynScriptEntry:\n//   None       \u2014 never save/load automatically\n//   Auto       \u2014 load on startup, save on quit\n//   ManualOnly \u2014 only when you call SaveState() / LoadState() from code\n\n// Saved files are plain .morph \u2014 human-readable, version-controllable:\n// entity Player {\n//   has hp: 75\n//   has level: 5\n// }\n\n\n// \u2500\u2500 HOT RELOAD \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// Enable \"Enable Hot Reload\" on MorphynController (Editor only)\n// Edit any .morph file \u2192 save \u2192 logic updates instantly in running game\n// Entity field values are preserved across reloads\n\n\n// \u2500\u2500 FULL EXAMPLE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n// enemy.morph\n/*\nentity Enemy {\n  has hp: 50\n  has reward: 100\n\n  on take_damage(amount) {\n    hp - amount -&gt; hp\n    check hp &lt;= 0: emit self.die\n  }\n\n  on die {\n    emit unity(\"OnEnemyDied\", reward)\n    emit self.destroy\n  }\n}\n*/\n\npublic class EnemyController : MonoBehaviour\n{\n    void Start()\n    {\n        // react to enemy death from C#\n        MorphynController.Instance.On(\"Enemy\", \"die\", args =&gt; {\n            int reward = System.Convert.ToInt32(args[0]);\n            ScoreManager.Add(reward);\n            Destroy(gameObject);\n        });\n    }\n\n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Bullet\"))\n            MorphynController.Instance.Emit(\"Enemy\", \"take_damage\", 25);\n    }\n\n    void OnDestroy()\n    {\n        MorphynController.Instance.Off(\"Enemy\", \"die\", /* handler ref */ null);\n    }\n}\n</code></pre>"},{"location":"learn/learn/","title":"Learn Morphyn in Y Minutes","text":"<pre><code># This is a comment\n// This too\n/* And this */\n\n# \u2500\u2500 ENTITIES \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# Everything in Morphyn lives inside an entity.\n# An entity has fields (state) and events (behavior).\n\nentity Player {\n  # \u2500\u2500 FIELDS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  has hp: 100          # number\n  has name: \"Hero\"     # string\n  has alive: true      # boolean\n  has nothing: null    # null\n\n  # Pool \u2014 ordered collection\n  has items: pool[]\n  has flags: pool[true, false, true]\n  has scores: pool[10, 20, 30]\n\n  # \u2500\u2500 BUILT-IN EVENTS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  # init runs once when entity is created\n  on init {\n    emit log(\"Player created:\", name)\n  }\n\n  # tick(dt) runs every frame \u2014 dt is milliseconds since last frame\n  on tick(dt) {\n    # use dt to make frame-independent timers\n  }\n\n  # \u2500\u2500 CUSTOM EVENTS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  on jump {\n    emit log(\"jumped!\")\n  }\n\n  on heal(amount) {\n    hp + amount -&gt; hp         # data flow: expression -&gt; target\n    check hp &gt; max_hp: {\n      max_hp -&gt; hp\n    }\n  }\n\n  # \u2500\u2500 DATA FLOW \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  on examples {\n    100 -&gt; hp                 # set\n    hp - 10 -&gt; hp             # subtract\n    hp * 2 -&gt; doubled         # store in local var\n    (hp + 50) * 0.5 -&gt; avg    # expression\n\n    # assign to pool slot (1-based index)\n    99 -&gt; scores.at[1]\n  }\n\n  # \u2500\u2500 CHECK (GUARD) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  on check_examples {\n    # inline action \u2014 only runs if condition is true\n    check hp &gt; 0: emit log(\"alive\")\n\n    # block action\n    check hp &lt;= 0: {\n      false -&gt; alive\n      emit self.destroy\n    }\n\n    # guard \u2014 stops event execution if condition is false\n    check alive\n    emit log(\"this only runs if alive was true\")\n\n    # logic operators\n    check hp &gt; 0 and alive: emit log(\"healthy\")\n    check hp &lt;= 0 or not alive: emit log(\"dead\")\n  }\n\n  # \u2500\u2500 EMIT \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  on emit_examples {\n    emit jump                       # send to self (implicit)\n    emit self.jump                  # send to self (explicit)\n    emit Enemy.take_damage(25)      # send to another entity\n    emit log(\"value:\", hp)          # built-in: print to console\n    emit input(\"Name: \", \"name\")    # built-in: read console input into field\n    emit unity(\"PlaySound\", \"hit\")  # built-in: call Unity callback\n    emit self.destroy               # built-in: mark for garbage collection\n  }\n\n  # \u2500\u2500 SYNC EMIT (returns a value) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  # Executes immediately, bypassing the event queue.\n  # Returns the last assigned value inside the called event.\n  on take_damage(amount) {\n    emit MathLib.clamp(hp - amount, 0, max_hp) -&gt; hp\n    # chains are allowed: MathLib.clamp can call other sync events\n    # direct recursion is forbidden: clamp cannot call itself\n    check hp &lt;= 0: emit self.die\n  }\n\n  # sync result can also go into a pool slot\n  on sync_to_pool {\n    emit MathLib.abs(scores.at[1]) -&gt; scores.at[1]\n  }\n\n  # \u2500\u2500 ARITHMETIC \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  on math {\n    hp + 10 -&gt; hp\n    hp - 5 -&gt; hp\n    hp * 2 -&gt; hp\n    hp / 4 -&gt; hp\n    hp % 3 -&gt; hp    # modulo\n  }\n\n  # \u2500\u2500 STRINGS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  on strings {\n    \"Hello\" + \" \" + \"World\" -&gt; greeting\n    check name == \"Hero\": emit log(\"is hero\")\n    check name != \"Villain\": emit log(\"not villain\")\n    # also: &gt; &lt; &gt;= &lt;= for lexicographic comparison\n  }\n\n  # \u2500\u2500 BLOCK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  on block_example {\n    {\n      hp + 10 -&gt; hp\n      emit log(\"healed\")\n    }\n  }\n}\n\n# \u2500\u2500 POOLS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nentity PoolExamples {\n  has items: pool[\"sword\", \"shield\", \"potion\"]\n  has enemies: pool[]\n\n  on init {\n    # read\n    items.count -&gt; size            # number of elements\n    items.at[1] -&gt; first           # get by index (1-based)\n\n    # write\n    \"axe\" -&gt; items.at[2]           # set by index\n\n    # commands\n    emit items.add(\"bow\")          # add to end (or spawn entity by name)\n    emit items.push(\"key\")         # add to front\n    emit items.insert(2, \"ring\")   # insert at index\n    emit items.remove(\"sword\")     # remove by value\n    emit items.remove_at(3)        # remove by index\n    emit items.pop                 # remove last\n    emit items.shift               # remove first\n    emit items.swap(1, 2)          # swap two indices\n    emit items.clear               # remove all\n\n    # call event on every element\n    emit enemies.each(\"take_damage\", 10)\n\n    # spawn entity instances into pool\n    emit enemies.add(\"Enemy\")      # clones Enemy entity, fires its init\n  }\n}\n\n# \u2500\u2500 SYNC LIBRARY PATTERN \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nentity MathLib {\n  on clamp(value, min, max) {\n    check value &lt; min: min -&gt; value\n    check value &gt; max: max -&gt; value\n    value -&gt; result               # last assigned = return value\n  }\n\n  on abs(value) {\n    check value &lt; 0: value * -1 -&gt; value\n    value -&gt; result\n  }\n\n  on lerp(a, b, t) {\n    a + (b - a) * t -&gt; result\n  }\n\n  on normalize(value, min, max) {\n    (value - min) / (max - min) -&gt; result\n  }\n}\n\n# \u2500\u2500 SUBSCRIPTIONS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# when: subscribe to another entity's event\n# unwhen: unsubscribe\n# when fires handlerEvent on subscriber with the same args as the original event\n\nentity Logger {\n  on init {\n    when Player.die : onPlayerDied       # subscribe\n    when Enemy.die  : onEnemyDied\n  }\n\n  on onPlayerDied {\n    emit log(\"Player died\")\n    unwhen Player.die : onPlayerDied     # unsubscribe after first death\n  }\n\n  on onEnemyDied {\n    emit log(\"Enemy died\")\n  }\n}\n\n# Rules:\n# - cannot subscribe to your own instance's events\n# - duplicate subscriptions are ignored\n# - destroyed entities are cleaned up automatically\n# - when/unwhen can be used in any event, not just init\n\n# \u2500\u2500 IMPORTS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# import \"mathlib.morph\"\n# import \"entities/enemy.morph\"\n# import \"../shared/utils.morph\"\n# Circular imports are prevented automatically.\n\n# \u2500\u2500 ENTITY LIFECYCLE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nentity Enemy {\n  has hp: 50\n  has alive: true\n\n  on init {\n    emit log(\"Enemy spawned\")\n  }\n\n  on take_damage(amount) {\n    hp - amount -&gt; hp\n    check hp &lt;= 0: {\n      false -&gt; alive\n      emit self.die\n    }\n  }\n\n  on die {\n    emit log(\"Enemy died\")\n    emit self.destroy               # marks entity for garbage collection\n                                    # removed from pools on next GarbageCollect\n  }\n}\n\n# \u2500\u2500 FULL EXAMPLE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nentity Game {\n  has score: 0\n  has enemies: pool[]\n  has timer: 0\n\n  on init {\n    emit enemies.add(\"Enemy\")\n    emit enemies.add(\"Enemy\")\n    emit log(\"Game started with\", enemies.count, \"enemies\")\n  }\n\n  on tick(dt) {\n    timer + dt -&gt; timer\n    check timer &gt;= 2000: {\n      emit enemies.add(\"Enemy\")\n      0 -&gt; timer\n    }\n  }\n\n  on player_attack(damage) {\n    emit enemies.each(\"take_damage\", damage)\n  }\n\n  on enemy_died {\n    score + 100 -&gt; score\n    emit log(\"Score:\", score)\n  }\n}\n</code></pre>"},{"location":"tools/vscode/","title":"Visual Studio Extension","text":""},{"location":"tools/vscode/#overview","title":"Overview","text":"<p>Syntax highlighting for .morphyn files in Visual Studio.</p>"},{"location":"tools/vscode/#installation","title":"Installation","text":"<ol> <li>Download <code>Morphyn.vsix</code> from Releases</li> <li>Double-click to install</li> <li>Restart Visual Studio</li> </ol>"},{"location":"tools/vscode/#features","title":"Features","text":"<ul> <li>Syntax highlighting (keywords, strings, numbers)</li> <li>File support: .morphyn, .mrph, .morph</li> <li>Auto-indent and bracket matching</li> <li>Comment support (# and / /)</li> </ul>"},{"location":"unity/api/","title":"Unity API Reference","text":""},{"location":"unity/api/#morphyncontroller","title":"MorphynController","text":"<p>The main component that loads and runs .morph files.</p>"},{"location":"unity/api/#settings","title":"Settings","text":"Setting Description Morphyn Scripts Drag .morph files here Run On Start Auto-load on Start() Enable Tick Send tick(dt) every frame Enable Hot Reload Edit files during Play mode Auto Save Save on quit Save Folder Where to save state"},{"location":"unity/api/#api-methods","title":"API Methods","text":"<pre><code>MorphynController morphyn = MorphynController.Instance;\n// Get value\nobject hp = morphyn.GetField(\"Player\", \"hp\");\ndouble hpValue = System.Convert.ToDouble(hp);\n// Set value\nmorphyn.SetField(\"Player\", \"hp\", 50);\n// Trigger event\nmorphyn.Emit(\"Player\", \"damage\", 25);\n// Trigger event which returns a value\nobject? result = morphyn.EmitSync(\"Player\", \"damage\", 25);\n// Subscribe entity to another entity's event\nmorphyn.Subscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n// Unsubscribe\nmorphyn.Unsubscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n// Subscribe C# method to a Morphyn event\nmorphyn.On(\"Player\", \"death\", args =&gt; Debug.Log(\"Player died!\"));\n// Unsubscribe C# method\nmorphyn.Off(\"Player\", \"death\", myHandler);\n// Save/Load\nmorphyn.SaveState();\nmorphyn.LoadState(\"Player\");\n</code></pre>"},{"location":"unity/api/#c-listeners","title":"C# Listeners","text":"<p>Subscribe any C# method directly to a Morphyn entity event using <code>On</code> and <code>Off</code>.</p>"},{"location":"unity/api/#on","title":"On","text":"<pre><code>MorphynController.Instance.On(entityName, eventName, handler);\n</code></pre> <p>The handler receives the same arguments the event was fired with as <code>object?[]</code>.</p> <p>Example: <pre><code>void Start()\n{\n    MorphynController.Instance.On(\"Player\", \"death\", OnPlayerDeath);\n    MorphynController.Instance.On(\"Player\", \"levelUp\", args =&gt; {\n        double level = Convert.ToDouble(args[0]);\n        levelUpScreen.Show((int)level);\n    });\n}\n\nvoid OnPlayerDeath(object?[] args)\n{\n    deathScreen.SetActive(true);\n    respawnButton.interactable = true;\n}\n\nvoid OnDestroy()\n{\n    // Always unsubscribe to avoid memory leaks\n    MorphynController.Instance.Off(\"Player\", \"death\", OnPlayerDeath);\n}\n</code></pre></p>"},{"location":"unity/api/#off","title":"Off","text":"<pre><code>MorphynController.Instance.Off(entityName, eventName, handler);\n</code></pre> <p>Note</p> <p>Always call <code>Off</code> in <code>OnDestroy</code> to avoid memory leaks and calls on destroyed objects.</p>"},{"location":"unity/api/#difference-from-subscribe","title":"Difference from Subscribe","text":"<code>On</code> / <code>Off</code> <code>Subscribe</code> / <code>Unsubscribe</code> Subscriber C# <code>Action&lt;object?[]&gt;</code> Morphyn entity event Use case Unity UI, audio, effects Morphyn-to-Morphyn logic Handler Any C# lambda or method Morphyn event name <pre><code>// C# reacts to Morphyn event\nmorphyn.On(\"Enemy\", \"death\", args =&gt; {\n    Instantiate(explosionPrefab, transform.position, Quaternion.identity);\n});\n\n// Morphyn entity reacts to Morphyn event\nmorphyn.Subscribe(\"Logger\", \"Enemy\", \"death\", \"onEnemyDeath\");\n</code></pre>"},{"location":"unity/api/#event-subscriptions-from-c","title":"Event Subscriptions from C","text":"<p>You can manage Morphyn entity subscriptions directly from C# using <code>Subscribe</code> and <code>Unsubscribe</code>.</p>"},{"location":"unity/api/#subscribe","title":"Subscribe","text":"<pre><code>// subscriberEntity will receive handlerEvent when targetEntity fires targetEvent\nmorphyn.Subscribe(subscriberEntityName, targetEntityName, targetEvent, handlerEvent);\n</code></pre> <p>Example \u2014 Logger reacts to Player death: <pre><code>MorphynController.Instance.Subscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n</code></pre> This is equivalent to writing inside a <code>.morph</code> file: <pre><code>when Player.death : onPlayerDeath\n</code></pre></p>"},{"location":"unity/api/#unsubscribe","title":"Unsubscribe","text":"<pre><code>morphyn.Unsubscribe(subscriberEntityName, targetEntityName, targetEvent, handlerEvent);\n</code></pre> <p>Example \u2014 remove subscription at runtime: <pre><code>// Player died for the first time \u2014 stop logging further deaths\nMorphynController.Instance.Unsubscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n</code></pre></p>"},{"location":"unity/api/#full-example","title":"Full Example","text":"<p>logger.morph: <pre><code>entity Logger {\n  has count: 0\n  on onPlayerDeath {\n    count + 1 -&gt; count\n    emit unity(\"Log\", \"Player died! Total deaths:\", count)\n  }\n  on onPlayerLevelUp(level) {\n    emit unity(\"Log\", \"Player reached level:\", level)\n  }\n}\n</code></pre></p> <p>GameManager.cs: <pre><code>using UnityEngine;\npublic class GameManager : MonoBehaviour\n{\n    void Start()\n    {\n        var morphyn = MorphynController.Instance;\n\n        // Subscribe Logger to Player events from C#\n        morphyn.Subscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n        morphyn.Subscribe(\"Logger\", \"Player\", \"levelUp\", \"onPlayerLevelUp\");\n    }\n\n    public void OnBossFightEnd()\n    {\n        // Stop logging deaths after boss fight ends\n        MorphynController.Instance.Unsubscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n    }\n}\n</code></pre></p>"},{"location":"unity/api/#notes","title":"Notes","text":"<ul> <li>Subscriptions set from C# behave exactly like <code>when</code>/<code>unwhen</code> inside <code>.morph</code> files</li> <li>An entity cannot subscribe to its own instance \u2014 <code>Subscribe(\"Player\", \"Player\", ...)</code> will log a warning and do nothing</li> <li>Duplicate subscriptions are ignored</li> <li>Dead entities are cleaned up automatically during garbage collection</li> </ul>"},{"location":"unity/api/#unity-bridge","title":"Unity Bridge","text":"<p>Call Unity functions from .morph files.</p>"},{"location":"unity/api/#setup","title":"Setup","text":"<pre><code>using UnityEngine;\nusing Morphyn.Unity;\npublic class GameManager : MonoBehaviour\n{\n    void Start()\n    {\n        // Register callback BEFORE MorphynController.Start()\nUnityBridge.Instance.RegisterCallback(\"PlaySound\", args =&gt; {\nstring soundName = args[0]?.ToString() ?? \"\";\nAudioSource.PlayOneShot(Resources.Load&lt;AudioClip&gt;(soundName));\n        });\nUnityBridge.Instance.RegisterCallback(\"ShowMessage\", args =&gt; {\nDebug.Log($\"Message: {string.Join(\" \", args)}\");\n        });\n    }\n}\n</code></pre>"},{"location":"unity/api/#calling-from-morphyn","title":"Calling from Morphyn","text":"<pre><code>entity Enemy {\n  has hp: 50\n  on damage(amount) {\n    hp - amount -&gt; hp\n    emit unity(\"PlaySound\", \"hit\")\n    check hp &lt;= 0: {\n      emit unity(\"PlaySound\", \"explosion\")\n      emit unity(\"ShowMessage\", \"Enemy destroyed!\")\n    }\n  }\n}\n</code></pre>"},{"location":"unity/api/#built-in-callbacks","title":"Built-in Callbacks","text":"<p>MorphynController includes these by default: <pre><code>emit unity(\"Log\", \"Hello\", \"World\")     # Debug.Log\nemit unity(\"Move\", 1, 0, 0)             # Move controller transform\nemit unity(\"Rotate\", 45)                # Rotate controller\n</code></pre></p>"},{"location":"unity/api/#hot-reload","title":"Hot Reload","text":"<p>Edit .morph files during Play mode - changes apply instantly. Enable: Check <code>Enable Hot Reload</code> on MorphynController Example: 1. Start Play mode 2. Open player.morph 3. Change <code>has damage: 10</code> to <code>has damage: 999</code> 4. Save file 5. Damage updates immediately - no restart needed</p>"},{"location":"unity/api/#saveload","title":"Save/Load","text":"<p>Morphyn saves entity state as readable .morph files. <pre><code>// Save all entities\nMorphynController.Instance.SaveState();\n// Saved to: Application.persistentDataPath/MorphynData/\n// Load single entity\nMorphynController.Instance.LoadState(\"Player\");\n// Auto-save on quit\nMorphynController.Instance.autoSave = true;\n</code></pre> Saved file example: <pre><code>entity Player {\n  has hp: 75\n  has level: 5\n  has gold: 230\n}\n</code></pre></p>"},{"location":"unity/api/#best-practices","title":"Best Practices","text":""},{"location":"unity/api/#1-one-morphyncontroller-per-scene","title":"1. One MorphynController per scene","text":"<pre><code>// Singleton - only one instance exists\nMorphynController.Instance\n</code></pre>"},{"location":"unity/api/#2-register-callbacks-early","title":"2. Register callbacks early","text":"<pre><code>[DefaultExecutionOrder(-100)]\npublic class Setup : MonoBehaviour\n{\n    void Awake() // Use Awake, not Start\n    {\nUnityBridge.Instance.RegisterCallback(\"MyCallback\", args =&gt; {});\n    }\n}\n</code></pre>"},{"location":"unity/api/#3-use-for-configs-not-gameplay-code","title":"3. Use for configs, not gameplay code","text":"<pre><code>// GOOD - config with logic\nentity ShopPrices { has swordCost: 100 }\n// BAD - complex gameplay\nentity ComplexAI { /* don't do this */ }\n</code></pre>"},{"location":"unity/api/#troubleshooting","title":"Troubleshooting","text":""},{"location":"unity/api/#morphyncontroller-not-found","title":"\"MorphynController not found\"","text":"<pre><code>if (MorphynController.Instance == null)\n{\nDebug.LogError(\"Add MorphynController to scene!\");\n}\n</code></pre>"},{"location":"unity/api/#callback-not-found","title":"\"Callback not found\"","text":"<ul> <li>Register callbacks in Awake(), not Start()</li> <li>Register BEFORE MorphynController loads scripts</li> </ul>"},{"location":"unity/api/#hot-reload-not-working","title":"Hot reload not working","text":"<ul> <li>Editor only (not in builds)</li> <li>File must be in Assets folder</li> <li>Check <code>Enable Hot Reload</code> is enabled</li> </ul>"},{"location":"unity/api/#values-not-updating","title":"Values not updating","text":"<pre><code>// After changing values, read again\nmorphyn.SetField(\"Player\", \"hp\", 50);\ndouble hp = System.Convert.ToDouble(morphyn.GetField(\"Player\", \"hp\")); // 50\n</code></pre>"},{"location":"unity/api/#subscribe-warning-entity-not-found","title":"Subscribe warning: entity not found","text":"<pre><code>// Make sure LoadAndRun() has been called before subscribing\n// Safe to call from Start() or later\nvoid Start()\n{\n    // MorphynController.Start() runs LoadAndRun() automatically if runOnStart is true\n    MorphynController.Instance.Subscribe(\"Logger\", \"Player\", \"death\", \"onPlayerDeath\");\n}\n</code></pre>"},{"location":"unity/api/#c-listener-called-after-object-destroyed","title":"C# listener called after object destroyed","text":"<pre><code>// Always unsubscribe in OnDestroy\nvoid OnDestroy()\n{\n    MorphynController.Instance.Off(\"Player\", \"death\", myHandler);\n}\n</code></pre>"},{"location":"unity/examples/","title":"Unity Examples","text":""},{"location":"unity/examples/#shop-with-discount-logic","title":"Shop with Discount Logic","text":"<p>shop.morph: <pre><code>entity Shop {\n  has swordPrice: 100\n  has potionPrice: 20\n  has armorPrice: 150\n\n  on apply_sale(percent) {\n    swordPrice - 50 -&gt; swordPrice\n    potionPrice - 10 -&gt; potionPrice\n    armorPrice - 75 -&gt; armorPrice\n    emit unity(\"Log\", \"SALE! 50% OFF!\")\n  }\n}\n</code></pre></p> <p>ShopUI.cs: <pre><code>using UnityEngine;\nusing UnityEngine.UI;\n\npublic class ShopUI : MonoBehaviour\n{\n    [SerializeField] private Text swordPriceText;\n\n    void Start()\n    {\n        UpdatePrices();\n    }\n\n    void UpdatePrices()\n    {\n        double price = System.Convert.ToDouble(\n            MorphynController.Instance.GetField(\"Shop\", \"swordPrice\")\n        );\n        swordPriceText.text = $\"Sword: ${price}\";\n    }\n\n    public void OnSaleButtonClick()\n    {\n        MorphynController.Instance.Emit(\"Shop\", \"apply_sale\", 50);\n        UpdatePrices(); // Shows 50\n    }\n}\n</code></pre></p>"},{"location":"unity/examples/#inventory-with-capacity","title":"Inventory with Capacity","text":"<p>inventory.morph: <pre><code>entity Inventory {\n  has items: pool[]\n  has capacity: 10\n  has gold: 100\n\n  on add_item(name) {\n    check items.count &lt; capacity: {\n      emit items.add(name)\n      emit unity(\"Log\", \"Added:\", name)\n    }\n\n    check items.count &gt;= capacity: {\n      emit unity(\"Log\", \"Inventory full!\")\n    }\n  }\n\n  on buy_item(name, cost) {\n    check gold &gt;= cost: {\n      gold - cost -&gt; gold\n      emit add_item(name)\n    }\n  }\n}\n</code></pre></p> <p>InventoryUI.cs: <pre><code>using UnityEngine;\nusing Morphyn.Runtime;\n\npublic class InventoryUI : MonoBehaviour\n{\n    public void AddSword()\n    {\n        MorphynController.Instance.Emit(\"Inventory\", \"add_item\", \"sword\");\n    }\n\n    public void BuyPotion()\n    {\n        MorphynController.Instance.Emit(\"Inventory\", \"buy_item\", \"potion\", 20);\n    }\n\n    public void ShowItems()\n    {\n        MorphynPool items = (MorphynPool)MorphynController.Instance.GetField(\"Inventory\", \"items\");\n\n        foreach (var item in items.Values)\n        {\n            Debug.Log($\"Item: {item}\");\n        }\n    }\n}\n</code></pre></p>"},{"location":"unity/examples/#enemy-spawner-with-timer","title":"Enemy Spawner with Timer","text":"<p>spawner.morph: <pre><code>entity Spawner {\n  has timer: 0\n  has interval: 2000\n  has maxEnemies: 10\n  has currentCount: 0\n\n  on tick(dt) {\n    timer + dt -&gt; timer\n\n    check timer &gt;= interval: {\n      check currentCount &lt; maxEnemies: {\n        emit spawn\n        0 -&gt; timer\n      }\n    }\n  }\n\n  on spawn {\n    currentCount + 1 -&gt; currentCount\n    emit unity(\"SpawnEnemy\")\n  }\n\n  on enemy_died {\n    currentCount - 1 -&gt; currentCount\n  }\n}\n</code></pre></p> <p>Spawner.cs: <pre><code>using UnityEngine;\nusing Morphyn.Unity;\n\npublic class Spawner : MonoBehaviour\n{\n    [SerializeField] private GameObject enemyPrefab;\n\n    void Start()\n    {\n        UnityBridge.Instance.RegisterCallback(\"SpawnEnemy\", args =&gt; {\n            Instantiate(enemyPrefab, transform.position, Quaternion.identity);\n        });\n    }\n\n    public void OnEnemyKilled()\n    {\n        MorphynController.Instance.Emit(\"Spawner\", \"enemy_died\");\n    }\n}\n</code></pre></p>"},{"location":"unity/installation/","title":"Unity Installation","text":""},{"location":"unity/installation/#installation-steps","title":"Installation Steps","text":"<ol> <li>Download <code>Morphyn.unitypackage</code> from Releases</li> <li>Import: <code>Assets &gt; Import Package &gt; Custom Package</code></li> <li>Add to scene: <code>GameObject &gt; Create Empty &gt; Add Component &gt; Morphyn Controller</code></li> <li>Drag <code>.morph</code> files into <code>Morphyn Scripts</code> array</li> <li>Check <code>Enable Hot Reload</code></li> <li>Press Play</li> </ol> <p>Done.</p>"},{"location":"unity/installation/#quick-start-example","title":"Quick Start Example","text":""},{"location":"unity/installation/#step-1-create-config-file","title":"Step 1: Create Config File","text":"<p>Create <code>player.morph</code> in your Assets folder: <pre><code>entity Player {\n  has hp: 100\n  has damage: 25\n  has level: 1\n\n  on level_up {\n    level + 1 -&gt; level\n    hp + 20 -&gt; hp\n    emit unity(\"Log\", \"Level up! New level:\", level)\n  }\n}\n</code></pre></p>"},{"location":"unity/installation/#step-2-use-in-c","title":"Step 2: Use in C","text":"<pre><code>using UnityEngine;\nusing Morphyn.Unity;\n\npublic class PlayerController : MonoBehaviour\n{\n    void Start()\n    {\n        // Read values\n        double hp = System.Convert.ToDouble(\n            MorphynController.Instance.GetField(\"Player\", \"hp\")\n        );\n\n        Debug.Log($\"Player HP: {hp}\");\n    }\n\n    void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.L))\n        {\n            // Trigger event\n            MorphynController.Instance.Emit(\"Player\", \"level_up\");\n        }\n    }\n}\n</code></pre>"},{"location":"unity/installation/#step-3-test-hot-reload","title":"Step 3: Test Hot Reload","text":"<ol> <li>Enter Play mode</li> <li>Open <code>player.morph</code></li> <li>Change <code>has hp: 100</code> to <code>has hp: 999</code></li> <li>Save</li> <li>HP updates instantly in running game!</li> </ol>"},{"location":"unity/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Unity API Reference</li> <li>Unity Examples</li> <li>Hot Reload Guide</li> </ul>"},{"location":"unity/overview/","title":"Unity Integration","text":"<p>Morphyn runs alongside your Unity project as a scripting layer for game logic and config. <code>.morph</code> files are loaded at runtime, hot-reloaded on save, and accessed from C# through a simple API.</p>"},{"location":"unity/overview/#hot-reload","title":"Hot Reload","text":"<p>Change values or logic in a <code>.morph</code> file while the game is running \u2014 no stopping Play mode.</p> <pre><code>entity Enemy {\n  has hp: 100      # change this to 999, save, done\n  has damage: 25\n}\n</code></pre>"},{"location":"unity/overview/#key-features","title":"Key Features","text":"<p>Hot reload \u2014 edit logic and values without restarting: <pre><code>on damage(amount) {\n  hp - amount -&gt; hp\n  check hp &lt;= 0: emit die\n}\n</code></pre></p> <p>Event-driven logic \u2014 reactive behaviors without state machines: <pre><code>entity Shop {\n  has gold: 100\n  on buy(cost) {\n    check gold &gt;= cost: {\n      gold - cost -&gt; gold\n      emit inventory.add(\"sword\")\n    }\n    check gold &lt; cost: emit unity(\"ShowError\", \"Not enough gold\")\n  }\n}\n</code></pre></p> <p>C# bridge \u2014 subscribe Unity methods directly to Morphyn events: <pre><code>MorphynController.Instance.On(\"Player\", \"die\", args =&gt; {\n    deathScreen.SetActive(true);\n});\n</code></pre></p>"},{"location":"unity/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Installation</li> <li>API Reference</li> <li>Learn in Y minutes</li> </ul>"}]}